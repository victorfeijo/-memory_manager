/*
 * File:   MemoryManager.cpp
 * Authors: INSERT YOUR NAME HERE
 * Strategy: INSERT THE MEMORY MANAGEMENT SCHEMA HERE (THE ALGORITHM YOU ARE IMPLEMENTING -- RANDOMLY GENERATED BY MOODLE AS A VARIATION)
 *
 * Created on ...
 */

#include <iostream>
#include "MemoryManager.h"

MemoryManager::MemoryManager(unsigned int size) { 
    // do not change
    this->_size = size;
    // INSERT YOUR CODE TO INITIALIZE OTHER PRIVATE ATTRIBUTES
    // ...
}

MemoryManager::MemoryManager(const MemoryManager& orig) {
}

MemoryManager::~MemoryManager() {
}

void MemoryManager::allocateMemoryForProcess(Process* process) {
    // INSERT YOUR CODE TO ALLOCATE MEMOTY FOR THE PROCESS
    // ...

}

void MemoryManager::deallocateMemoryOfProcess(Process* process) {
    // INSERT YOUR CODE TO DEALLOCATE MEMORY OF THE PROCESS
    // ...

}

unsigned int MemoryManager::getNumPartitions() {
    return NUMBER_PARTITIONS;
}

Partition* MemoryManager::getPartition(unsigned int index) {
    // INSERT YOUR CODE TO RETURN THE PARTITION AT INDEX index
    // ...

    return _partitions[index];
}


void MemoryManager::showAllocatedMemory() {
    unsigned int beginAllocatedAddress, endAllocatedAddress, totalAllocated, processId, internalFragmentation, externalFragmentation;
    // INSERT YOUR CODE TO SHOW EACH ONE OF THE ALLOCATED MEMORY PARTITIONS, INCLUDING INTERNAL AND EXTERNAL (THE FOLLOWING) FRAGMENTATION
    // ...

    // for ... {  // for each partition...  
    // ...
    
    beginAllocatedAddress = 0;
    endAllocatedAddress = 0;
    totalAllocated = 0;
    processId = 0;
    internalFragmentation = 0;
    externalFragmentation = 0;
    
    // no not change the next line (the way information are shown)
    std::cout << "\tAllocd: " << "B=" << (beginAllocatedAddress) << ", \tE=" << (endAllocatedAddress) << ", \tT=" << (totalAllocated) << ", \tPID=" << (processId)
            << ", \tIF=" << (internalFragmentation) << ", \tEF=" << (externalFragmentation) << "\n";
    // }
}

unsigned int MemoryManager::getSize() const {
    return _size;
}

void MemoryManager::createFixedPartitions() {
    // Create fixed partitions of sequencial increasing sizes using fractions
    unsigned int divisor = calculateDivisor(NUMBER_PARTITIONS);
    unsigned int actualStart = 0;
    for (unsigned int index = 0; index < NUMBER_PARTITIONS-1; index++) {
        unsigned int actualSize = _size * (index+1 / divisor);
        _partitions[index] = new Partition(actualStart, actualStart+actualSize-1);
        actualStart += actualSize;
    }
    // The last partition ends at the end of the memory,
    // ignoring losses caused by integer divisions
    _partitions[NUMBER_PARTITIONS-1] = new Partition(actualStart, _size-1);
}

unsigned int MemoryManager::calculateDivisor(unsigned int number) {
    unsigned int sum = 0;
    for (unsigned int k = 1; k <= number; k++) {
        sum += k;
    }
    return sum;
}

Partition::Partition(unsigned int begin, unsigned int end) {
    _beginAddress = begin;
    _endAddress = end;
}
